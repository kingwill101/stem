"use strict";(globalThis.webpackChunksite=globalThis.webpackChunksite||[]).push([[8055],{1470:(e,t,n)=>{n.d(t,{A:()=>v});var i=n(6540),r=n(4164),a=n(7559),s=n(3104),l=n(6347),o=n(205),d=n(7485),c=n(1682),m=n(679);function u(e){return i.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:t,children:n}=e;return(0,i.useMemo)(()=>{const e=t??function(e){return u(e).map(({props:{value:e,label:t,attributes:n,default:i}})=>({value:e,label:t,attributes:n,default:i}))}(n);return function(e){const t=(0,c.XI)(e,(e,t)=>e.value===t.value);if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[t,n])}function h({value:e,tabValues:t}){return t.some(t=>t.value===e)}function g({queryString:e=!1,groupId:t}){const n=(0,l.W6)(),r=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,d.aZ)(r),(0,i.useCallback)(e=>{if(!r)return;const t=new URLSearchParams(n.location.search);t.set(r,e),n.replace({...n.location,search:t.toString()})},[r,n])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,a=p(e),[s,l]=(0,i.useState)(()=>function({defaultValue:e,tabValues:t}){if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!h({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const n=t.find(e=>e.default)??t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:a})),[d,c]=g({queryString:n,groupId:r}),[u,f]=function({groupId:e}){const t=function(e){return e?`docusaurus.tab.${e}`:null}(e),[n,r]=(0,m.Dv)(t);return[n,(0,i.useCallback)(e=>{t&&r.set(e)},[t,r])]}({groupId:r}),x=(()=>{const e=d??u;return h({value:e,tabValues:a})?e:null})();(0,o.A)(()=>{x&&l(x)},[x]);return{selectedValue:s,selectValue:(0,i.useCallback)(e=>{if(!h({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);l(e),c(e),f(e)},[c,f,a]),tabValues:a}}var x=n(2303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var k=n(4848);function y({className:e,block:t,selectedValue:n,selectValue:i,tabValues:a}){const l=[],{blockElementScrollPositionUntilNextRender:o}=(0,s.a_)(),d=e=>{const t=e.currentTarget,r=l.indexOf(t),s=a[r].value;s!==n&&(o(t),i(s))},c=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,k.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},e),children:a.map(({value:e,label:t,attributes:i})=>(0,k.jsx)("li",{role:"tab",tabIndex:n===e?0:-1,"aria-selected":n===e,ref:e=>{l.push(e)},onKeyDown:c,onClick:d,...i,className:(0,r.A)("tabs__item",b.tabItem,i?.className,{"tabs__item--active":n===e}),children:t??e},e))})}function w({lazy:e,children:t,selectedValue:n}){const a=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){const e=a.find(e=>e.props.value===n);return e?(0,i.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,k.jsx)("div",{className:"margin-top--md",children:a.map((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==n}))})}function j(e){const t=f(e);return(0,k.jsxs)("div",{className:(0,r.A)(a.G.tabs.container,"tabs-container",b.tabList),children:[(0,k.jsx)(y,{...t,...e}),(0,k.jsx)(w,{...t,...e})]})}function v(e){const t=(0,x.A)();return(0,k.jsx)(j,{...e,children:u(e.children)},String(t))}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var i=n(6540);const r={},a=i.createContext(r);function s(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:t},e.children)}},9183:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>m});const i=JSON.parse('{"id":"core-concepts/rate-limiting","title":"Rate Limiting","description":"Stem supports per-task rate limits via TaskOptions.rateLimit and a pluggable","source":"@site/docs/core-concepts/rate-limiting.md","sourceDirName":"core-concepts","slug":"/core-concepts/rate-limiting","permalink":"/stem/core-concepts/rate-limiting","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/stem/tree/main/.site/docs/docs/core-concepts/rate-limiting.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Rate Limiting","sidebar_label":"Rate Limiting","sidebar_position":4,"slug":"/core-concepts/rate-limiting"},"sidebar":"docs","previous":{"title":"Payload Signing","permalink":"/stem/core-concepts/signing"},"next":{"title":"Uniqueness","permalink":"/stem/core-concepts/uniqueness"}}');var r=n(4848),a=n(8453),s=n(1470),l=n(9365);const o={title:"Rate Limiting",sidebar_label:"Rate Limiting",sidebar_position:4,slug:"/core-concepts/rate-limiting"},d=void 0,c={},m=[{value:"Quick start",id:"quick-start",level:2},{value:"Docs snippet (in-memory demo)",id:"docs-snippet-in-memory-demo",level:3},{value:"Rate limit syntax",id:"rate-limit-syntax",level:2},{value:"How it works",id:"how-it-works",level:2},{value:"Redis-backed limiter example",id:"redis-backed-limiter-example",level:2},{value:"Observability",id:"observability",level:2},{value:"Keying behavior",id:"keying-behavior",level:2},{value:"Redis limiter wiring",id:"redis-limiter-wiring",level:2},{value:"Tips",id:"tips",level:2},{value:"Next steps",id:"next-steps",level:2}];function u(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["Stem supports per-task rate limits via ",(0,r.jsx)(t.code,{children:"TaskOptions.rateLimit"})," and a pluggable\n",(0,r.jsx)(t.code,{children:"RateLimiter"})," interface. This lets you throttle hot handlers with a shared\nRedis-backed limiter or custom driver."]}),"\n","\n",(0,r.jsx)(t.h2,{id:"quick-start",children:"Quick start"}),"\n",(0,r.jsxs)(s.A,{children:[(0,r.jsx)(l.A,{value:"task-options",label:"Task Options",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="lib/shared.dart" file=<rootDir>/../packages/stem/example/rate_limit_delay/lib/shared.dart#rate-limit-task-options',children:"  final registry = SimpleTaskRegistry()\n    ..register(\n      FunctionTaskHandler<void>(\n        name: _taskName,\n        options: const TaskOptions(\n          queue: 'throttled',\n          maxRetries: 0,\n          visibilityTimeout: Duration(seconds: 60),\n          rateLimit: '3/s',\n        ),\n        entrypoint: _renderEntrypoint,\n      ),\n    );\n"})})}),(0,r.jsx)(l.A,{value:"worker-wiring",label:"Worker Wiring",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="bin/worker.dart" file=<rootDir>/../packages/stem/example/rate_limit_delay/bin/worker.dart#rate-limit-worker',children:"  final worker = Worker(\n    broker: broker,\n    registry: registry,\n    backend: backend,\n    rateLimiter: rateLimiter,\n    queue: 'throttled',\n    consumerName:\n        Platform.environment['WORKER_NAME'] ?? 'rate-limit-demo-worker',\n    subscription: RoutingSubscription.singleQueue('throttled'),\n    concurrency: 2,\n  );\n"})})}),(0,r.jsx)(l.A,{value:"producer-enqueue",label:"Producer Enqueue",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="bin/producer.dart" file=<rootDir>/../packages/stem/example/rate_limit_delay/bin/producer.dart#rate-limit-producer-enqueue',children:"  for (var i = 0; i < totalJobs; i++) {\n    final delaySeconds = i >= totalJobs / 2 ? 4 : 0;\n    final notBefore = delaySeconds > 0\n        ? DateTime.now().add(Duration(seconds: delaySeconds))\n        : null;\n    final priority = i.isEven ? 9 : 2;\n    final route = routing.resolve(\n      RouteRequest(\n        task: taskName(),\n        headers: const {},\n        queue: 'throttled',\n      ),\n    );\n    final appliedPriority = route.effectivePriority(priority);\n\n    final id = await stem.enqueue(\n      taskName(),\n      args: {\n        'job': i + 1,\n        'scheduledFor': notBefore?.toIso8601String(),\n        'requestedPriority': priority,\n      },\n      options: TaskOptions(\n        queue: 'throttled',\n        priority: priority,\n        maxRetries: 0,\n      ),\n      notBefore: notBefore,\n      meta: {\n        'requestedPriority': priority,\n        'appliedPriority': appliedPriority,\n        if (notBefore != null) 'scheduledFor': notBefore.toIso8601String(),\n      },\n    );\n\n    stdout.writeln(\n      '[producer] job=${i + 1} priority=$priority '\n      'applied=$appliedPriority delay=${delaySeconds}s id=$id',\n    );\n  }\n"})})})]}),"\n",(0,r.jsx)(t.h3,{id:"docs-snippet-in-memory-demo",children:"Docs snippet (in-memory demo)"}),"\n",(0,r.jsxs)(s.A,{children:[(0,r.jsx)(l.A,{value:"task",label:"Define a rate-limited task",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="lib/rate_limiting.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/rate_limiting.dart#rate-limit-task-options',children:"class RateLimitedTask extends TaskHandler<void> {\n  @override\n  String get name => 'demo.rateLimited';\n\n  @override\n  TaskOptions get options => const TaskOptions(\n    rateLimit: '10/s',\n    maxRetries: 3,\n  );\n\n  @override\n  Future<void> call(TaskContext context, Map<String, Object?> args) async {\n    final actor = args['actor'] as String? ?? 'anonymous';\n    print('Handled rate-limited task for $actor');\n  }\n}\n"})})}),(0,r.jsx)(l.A,{value:"limiter-config",label:"Limiter config + state",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="lib/rate_limiting.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/rate_limiting.dart#rate-limit-demo-limiter-config',children:"  DemoRateLimiter({required this.capacity, required this.interval});\n\n  final int capacity;\n  final Duration interval;\n  int _used = 0;\n  DateTime _windowStart = DateTime.now();\n"})})}),(0,r.jsx)(l.A,{value:"limiter-acquire",label:"Limiter acquire decision",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="lib/rate_limiting.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/rate_limiting.dart#rate-limit-demo-limiter-acquire',children:"  @override\n  Future<RateLimitDecision> acquire(\n    String key, {\n    int tokens = 1,\n    Duration? interval,\n    Map<String, Object?>? meta,\n  }) async {\n    final window = interval ?? this.interval;\n    final now = DateTime.now();\n    final elapsed = now.difference(_windowStart);\n    if (elapsed >= window) {\n      _windowStart = now;\n      _used = 0;\n    }\n\n    if (_used + tokens <= capacity) {\n      _used += tokens;\n      return RateLimitDecision(allowed: true, meta: {'key': key});\n    }\n\n    final retryAfter = window - elapsed;\n    return RateLimitDecision(\n      allowed: false,\n      retryAfter: retryAfter.isNegative ? Duration.zero : retryAfter,\n      meta: {'key': key},\n    );\n  }\n"})})}),(0,r.jsx)(l.A,{value:"worker",label:"Wire worker with rate limiter",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="lib/rate_limiting.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/rate_limiting.dart#rate-limit-worker',children:"  final limiter = DemoRateLimiter(\n    capacity: 2,\n    interval: const Duration(seconds: 1),\n  );\n  final workerConfig = StemWorkerConfig(rateLimiter: limiter);\n"})})}),(0,r.jsx)(l.A,{value:"producer",label:"Enqueue with tenant header",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="lib/rate_limiting.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/rate_limiting.dart#rate-limit-producer',children:"Future<String> enqueueRateLimited(Stem stem) async {\n  return stem.enqueue(\n    'demo.rateLimited',\n    args: {'actor': 'acme'},\n    headers: const {'tenant': 'acme'},\n  );\n}\n"})})}),(0,r.jsx)(l.A,{value:"registry",label:"Bootstrap StemApp",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="lib/rate_limiting.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/rate_limiting.dart#rate-limit-demo-registry',children:"  // #region rate-limit-worker\n  final limiter = DemoRateLimiter(\n    capacity: 2,\n    interval: const Duration(seconds: 1),\n  );\n  final workerConfig = StemWorkerConfig(rateLimiter: limiter);\n  // #endregion rate-limit-worker\n  final app = await StemApp.inMemory(\n    tasks: [RateLimitedTask()],\n    workerConfig: workerConfig,\n  );\n"})})}),(0,r.jsx)(l.A,{value:"start",label:"Start worker",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="lib/rate_limiting.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/rate_limiting.dart#rate-limit-demo-worker-start',children:"  await app.start();\n"})})}),(0,r.jsx)(l.A,{value:"stem",label:"Create Stem client",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="lib/rate_limiting.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/rate_limiting.dart#rate-limit-demo-stem',children:"  final stem = app.stem;\n"})})}),(0,r.jsx)(l.A,{value:"enqueue",label:"Enqueue demo task",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="lib/rate_limiting.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/rate_limiting.dart#rate-limit-demo-enqueue',children:"  await enqueueRateLimited(stem);\n"})})}),(0,r.jsx)(l.A,{value:"shutdown",label:"Shutdown cleanly",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="lib/rate_limiting.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/rate_limiting.dart#rate-limit-demo-shutdown',children:"  await app.close();\n"})})})]}),"\n",(0,r.jsxs)(t.p,{children:["Run the ",(0,r.jsx)(t.code,{children:"rate_limit_delay"})," example for a full demo:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"packages/stem/example/rate_limit_delay"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"rate-limit-syntax",children:"Rate limit syntax"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"rateLimit"})," accepts short strings like:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"10/s"})," \u2014 10 tokens per second"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"100/m"})," \u2014 100 tokens per minute"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"500/h"})," \u2014 500 tokens per hour"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The worker parses ",(0,r.jsx)(t.code,{children:"rateLimit"})," for each task."]}),"\n",(0,r.jsxs)(t.li,{children:["The worker asks the ",(0,r.jsx)(t.code,{children:"RateLimiter"})," for an acquire decision."]}),"\n",(0,r.jsxs)(t.li,{children:["If denied, the task is retried with backoff and ",(0,r.jsx)(t.code,{children:"rateLimited=true"})," metadata."]}),"\n",(0,r.jsxs)(t.li,{children:["Retry delays come from the limiter ",(0,r.jsx)(t.code,{children:"retryAfter"})," if provided, otherwise the\nworker\u2019s retry strategy."]}),"\n",(0,r.jsx)(t.li,{children:"If granted, the task executes immediately."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"redis-backed-limiter-example",children:"Redis-backed limiter example"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"example/rate_limit_delay"})," demo ships a Redis fixed-window limiter. It:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"shares tokens across multiple workers,"}),"\n",(0,r.jsx)(t.li,{children:"logs when a token is granted or denied,"}),"\n",(0,r.jsx)(t.li,{children:"reschedules denied tasks with retry metadata."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Inspect it here:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="lib/rate_limiter.dart" file=<rootDir>/../packages/stem/example/rate_limit_delay/lib/rate_limiter.dart#rate-limit-redis-limiter',children:"class RedisFixedWindowRateLimiter implements RateLimiter {\n  RedisFixedWindowRateLimiter._(\n    this._connection,\n    this._command, {\n    required this.namespace,\n  });\n\n  final RedisConnection _connection;\n  final Command _command;\n  final String namespace;\n  bool _closed = false;\n\n  static const _script = '''\nlocal key = KEYS[1]\nlocal limit = tonumber(ARGV[1])\nlocal interval = tonumber(ARGV[2])\n\nlocal current = redis.call('GET', key)\nif not current then\n  redis.call('SET', key, 1, 'PX', interval)\n  return {1, interval}\nend\n\ncurrent = tonumber(current)\nif current < limit then\n  redis.call('INCR', key)\n  local ttl = redis.call('PTTL', key)\n  if ttl < 0 then ttl = interval end\n  return {1, ttl}\nend\n\nlocal ttl = redis.call('PTTL', key)\nif ttl < 0 then ttl = interval end\nreturn {0, ttl}\n''';\n\n  static Future<RedisFixedWindowRateLimiter> connect(\n    String uri, {\n    String namespace = 'stem-demo',\n  }) async {\n    final parsed = Uri.parse(uri);\n    final host = parsed.host.isNotEmpty ? parsed.host : 'localhost';\n    final port = parsed.hasPort ? parsed.port : 6379;\n    final connection = RedisConnection();\n    final scheme = parsed.scheme.isEmpty ? 'redis' : parsed.scheme;\n\n    if (scheme == 'rediss') {\n      throw UnsupportedError(\n        'TLS connections are not implemented for the rate limiter demo. '\n        'Use redis:// URLs or extend the example.',\n      );\n    }\n\n    final command = await connection.connect(host, port);\n\n    if (parsed.userInfo.isNotEmpty) {\n      final parts = parsed.userInfo.split(':');\n      final password = parts.length == 2 ? parts[1] : parts[0];\n      await command.send_object(['AUTH', password]);\n    }\n\n    if (parsed.pathSegments.isNotEmpty) {\n      final db = int.tryParse(parsed.pathSegments.first);\n      if (db != null) {\n        await command.send_object(['SELECT', db]);\n      }\n    }\n\n    final resolvedNamespace = parsed.queryParameters['ns'] ?? namespace.trim();\n\n    return RedisFixedWindowRateLimiter._(\n      connection,\n      command,\n      namespace: resolvedNamespace.isEmpty ? 'stem-demo' : resolvedNamespace,\n    );\n  }\n\n  String _keyFor(String key) => '$namespace:rate:$key';\n\n  @override\n  Future<RateLimitDecision> acquire(\n    String key, {\n    int tokens = 1,\n    Duration? interval,\n    Map<String, Object?>? meta,\n  }) async {\n    final window = interval ?? const Duration(seconds: 1);\n    final response = await _command.send_object([\n      'EVAL',\n      _script,\n      1,\n      _keyFor(key),\n      tokens,\n      window.inMilliseconds,\n    ]);\n\n    if (response is! List || response.length != 2) {\n      throw StateError(\n        'Unexpected response from rate limiter script: $response',\n      );\n    }\n\n    final allowed = (response[0] as num).toInt() == 1;\n    final ttlMs = (response[1] as num).toInt();\n    final remainingMs = ttlMs < 0 ? window.inMilliseconds : ttlMs;\n    final retryAfter = allowed ? null : Duration(milliseconds: remainingMs);\n\n    final decision = RateLimitDecision(\n      allowed: allowed,\n      retryAfter: retryAfter,\n      meta: {\n        'windowMs': window.inMilliseconds,\n        'remainingMs': remainingMs,\n        if (meta != null) ...meta,\n      },\n    );\n\n    final status = allowed ? 'granted' : 'denied';\n    final retryText = retryAfter == null\n        ? 'available immediately'\n        : 'retry in ${retryAfter.inMilliseconds}ms';\n    stdout.writeln(\n      '[rate-limiter][$status] key=$key tokens=$tokens window=${window.inMilliseconds}ms -> $retryText',\n    );\n\n    return decision;\n  }\n\n  Future<void> close() async {\n    if (_closed) return;\n    _closed = true;\n    await _connection.close();\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"observability",children:"Observability"}),"\n",(0,r.jsx)(t.p,{children:"When a task is rate limited:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"context.meta['rateLimited']"})," is set on the retry attempt,"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"taskRetry"})," signals include retry metadata,"]}),"\n",(0,r.jsx)(t.li,{children:"worker logs show the limiter decision (if you log it)."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"keying-behavior",children:"Keying behavior"}),"\n",(0,r.jsx)(t.p,{children:"The worker uses a default rate-limit key of:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"<taskName>:<tenant>\n"})}),"\n",(0,r.jsxs)(t.p,{children:["If no tenant header is set, it defaults to ",(0,r.jsx)(t.code,{children:"global"}),". Add a ",(0,r.jsx)(t.code,{children:"tenant"})," header when\nenqueuing tasks to enforce per-tenant limits."]}),"\n",(0,r.jsx)(t.h2,{id:"redis-limiter-wiring",children:"Redis limiter wiring"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"rate_limit_delay"})," example reads ",(0,r.jsx)(t.code,{children:"STEM_RATE_LIMIT_URL"})," to point the limiter\nat Redis. Use a dedicated Redis DB or key prefix to keep limiter state isolated\nfrom your broker/result backend."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",metastring:'title="lib/shared.dart" file=<rootDir>/../packages/stem/example/rate_limit_delay/lib/shared.dart#rate-limit-redis-connector',children:"Future<RedisFixedWindowRateLimiter> connectRateLimiter(String uri) =>\n    RedisFixedWindowRateLimiter.connect(uri);\n"})}),"\n",(0,r.jsx)(t.h2,{id:"tips",children:"Tips"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Use shared Redis for global limits across worker processes."}),"\n",(0,r.jsx)(t.li,{children:"Keep the rate limit key stable (by default it uses task name + tenant)."}),"\n",(0,r.jsx)(t.li,{children:"Start with generous limits, then tighten after observing throughput."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["See ",(0,r.jsx)(t.a,{href:"/stem/core-concepts/tasks",children:"Tasks & Retries"})," for other ",(0,r.jsx)(t.code,{children:"TaskOptions"})," knobs."]}),"\n",(0,r.jsxs)(t.li,{children:["Use ",(0,r.jsx)(t.a,{href:"/stem/core-concepts/observability",children:"Observability"})," to instrument rate-limited flows."]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},9365:(e,t,n)=>{n.d(t,{A:()=>s});n(6540);var i=n(4164);const r={tabItem:"tabItem_Ymn6"};var a=n(4848);function s({children:e,hidden:t,className:n}){return(0,a.jsx)("div",{role:"tabpanel",className:(0,i.A)(r.tabItem,n),hidden:t,children:e})}}}]);