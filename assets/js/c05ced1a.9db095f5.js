"use strict";(globalThis.webpackChunksite=globalThis.webpackChunksite||[]).push([[3699],{1851:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"core-concepts/workflows","title":"Workflows","description":"Stem Workflows let you orchestrate multi-step business processes with durable","source":"@site/docs/core-concepts/workflows.md","sourceDirName":"core-concepts","slug":"/core-concepts/workflows","permalink":"/stem/core-concepts/workflows","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/stem/tree/main/.site/docs/docs/core-concepts/workflows.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"Workflows","sidebar_label":"Workflows","sidebar_position":8,"slug":"/core-concepts/workflows"}}');var t=r(4848),o=r(8453);const i={title:"Workflows",sidebar_label:"Workflows",sidebar_position:8,slug:"/core-concepts/workflows"},a=void 0,l={},c=[{value:"Runtime Overview",id:"runtime-overview",level:2},{value:"StemClient Entrypoint",id:"stemclient-entrypoint",level:2},{value:"Declaring Typed Flows",id:"declaring-typed-flows",level:2},{value:"Workflow Scripts",id:"workflow-scripts",level:2},{value:"Annotated Workflows (stem_builder)",id:"annotated-workflows-stem_builder",level:2},{value:"Starting &amp; Awaiting Workflows",id:"starting--awaiting-workflows",level:2},{value:"Cancellation policies",id:"cancellation-policies",level:3},{value:"Suspension, Events, and Groups of Runs",id:"suspension-events-and-groups-of-runs",level:2},{value:"Run Leases &amp; Multi-Worker Recovery",id:"run-leases--multi-worker-recovery",level:2},{value:"Deterministic Tests with WorkflowClock",id:"deterministic-tests-with-workflowclock",level:2},{value:"Payload Encoders in Workflow Apps",id:"payload-encoders-in-workflow-apps",level:2},{value:"Tooling Tips",id:"tooling-tips",level:2}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Stem Workflows let you orchestrate multi-step business processes with durable\nstate, typed results, automatic retries, and event-driven resumes. The\n",(0,t.jsx)(n.code,{children:"StemWorkflowApp"})," helper wires together a ",(0,t.jsx)(n.code,{children:"Stem"})," instance, workflow store,\nevent bus, and runtime so you can start runs, monitor progress, and interact\nwith suspended steps from one place."]}),"\n",(0,t.jsx)(n.h2,{id:"runtime-overview",children:"Runtime Overview"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="bin/workflows.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/workflows.dart#workflows-app-create',children:"  final workflowApp = await StemWorkflowApp.create(\n    flows: [ApprovalsFlow.flow],\n    scripts: [retryScript],\n    broker: redisBrokerFactory('redis://127.0.0.1:56379'),\n    backend: redisResultBackendFactory('redis://127.0.0.1:56379/1'),\n    storeFactory: postgresWorkflowStoreFactory(\n      'postgresql://postgres:postgres@127.0.0.1:65432/stem',\n    ),\n    eventBusFactory: WorkflowEventBusFactory.inMemory(),\n    workerConfig: const StemWorkerConfig(queue: 'workflow'),\n  );\n"})}),"\n",(0,t.jsx)(n.p,{children:"Start the runtime once the app is constructed:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:"file=<rootDir>/../packages/stem/example/docs_snippets/lib/workflows.dart#workflows-app-start",children:"  await workflowApp.start();\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"StemWorkflowApp"})," exposes:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"runtime"})," \u2013 registers ",(0,t.jsx)(n.code,{children:"Flow"}),"/",(0,t.jsx)(n.code,{children:"WorkflowScript"})," definitions and dequeues runs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"store"})," \u2013 persists checkpoints, suspension metadata, and results."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"eventBus"})," \u2013 emits topics that resume waiting steps."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"app"})," \u2013 the underlying ",(0,t.jsx)(n.code,{children:"StemApp"})," (broker + result backend + worker)."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"stemclient-entrypoint",children:"StemClient Entrypoint"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"StemClient"})," is the shared entrypoint when you want a single object to own the\nbroker, result backend, and workflow helpers. It creates workflow apps and\nworkers with consistent configuration so you don't pass broker/backend handles\naround."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="bin/workflows_client.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/workflows.dart#workflows-client',children:"Future<void> bootstrapWorkflowClient() async {\n  final client = await StemClient.inMemory();\n  final app = await client.createWorkflowApp(flows: [ApprovalsFlow.flow]);\n  await app.start();\n  await app.close();\n  await client.close();\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"declaring-typed-flows",children:"Declaring Typed Flows"}),"\n",(0,t.jsxs)(n.p,{children:["Flows use the declarative DSL (",(0,t.jsx)(n.code,{children:"FlowBuilder"}),") to capture ordered steps. Specify\n",(0,t.jsx)(n.code,{children:"Flow<T>"})," to document the completion type; generic metadata is preserved all the\nway through ",(0,t.jsx)(n.code,{children:"WorkflowResult<T>"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="lib/workflows/approvals_flow.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/workflows.dart#workflows-flow',children:"class ApprovalsFlow {\n  static final flow = Flow<String>(\n    name: 'approvals.flow',\n    build: (flow) {\n      flow.step('draft', (ctx) async {\n        final payload = ctx.params['draft'] as Map<String, Object?>;\n        return payload['documentId'];\n      });\n\n      flow.step('manager-review', (ctx) async {\n        final resume = ctx.takeResumeData() as Map<String, Object?>?;\n        if (resume == null) {\n          await ctx.awaitEvent('approvals.manager');\n          return null;\n        }\n        return resume['approvedBy'] as String?;\n      });\n\n      flow.step('finalize', (ctx) async {\n        final approvedBy = ctx.previousResult as String?;\n        return 'approved-by:$approvedBy';\n      });\n    },\n  );\n}\n\nFuture<void> registerFlow(StemWorkflowApp workflowApp) async {\n  workflowApp.runtime.registerWorkflow(ApprovalsFlow.flow.definition);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Steps re-run from the top after every suspension, so handlers must be\nidempotent and rely on ",(0,t.jsx)(n.code,{children:"FlowContext"})," helpers: ",(0,t.jsx)(n.code,{children:"iteration"}),", ",(0,t.jsx)(n.code,{children:"takeResumeData"}),",\n",(0,t.jsx)(n.code,{children:"sleep"}),", ",(0,t.jsx)(n.code,{children:"awaitEvent"}),", ",(0,t.jsx)(n.code,{children:"idempotencyKey"}),", and persisted step outputs."]}),"\n",(0,t.jsx)(n.h2,{id:"workflow-scripts",children:"Workflow Scripts"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"WorkflowScript"})," offers a higher-level facade that feels like a regular async\nfunction. You still get typed results and step-level durability, but the DSL\nhandles ",(0,t.jsx)(n.code,{children:"ctx.step"})," registration automatically."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="lib/workflows/retry_script.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/workflows.dart#workflows-script',children:"final retryScript = WorkflowScript(\n  name: 'billing.retry-script',\n  run: (script) async {\n    final chargeId = await script.step<String>('charge', (ctx) async {\n      final resume = ctx.takeResumeData() as Map<String, Object?>?;\n      if (resume == null) {\n        await ctx.awaitEvent('billing.charge.prepared');\n        return 'pending';\n      }\n      return resume['chargeId'] as String;\n    });\n\n    final receipt = await script.step<String>('confirm', (ctx) async {\n      ctx.idempotencyKey('confirm-$chargeId');\n      return 'receipt-$chargeId';\n    });\n\n    return receipt;\n  },\n);\n\nfinal retryDefinition = retryScript.definition;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Scripts can enable ",(0,t.jsx)(n.code,{children:"autoVersion: true"})," inside ",(0,t.jsx)(n.code,{children:"script.step"})," calls to track loop\niterations using the ",(0,t.jsx)(n.code,{children:"stepName#iteration"})," naming convention."]}),"\n",(0,t.jsx)(n.h2,{id:"annotated-workflows-stem_builder",children:"Annotated Workflows (stem_builder)"}),"\n",(0,t.jsxs)(n.p,{children:["If you prefer decorators over the DSL, annotate workflow classes and tasks with\n",(0,t.jsx)(n.code,{children:"@WorkflowDefn"}),", ",(0,t.jsx)(n.code,{children:"@workflow.run"}),", ",(0,t.jsx)(n.code,{children:"@workflow.step"}),", and ",(0,t.jsx)(n.code,{children:"@TaskDefn"}),", then generate\nthe registry with ",(0,t.jsx)(n.code,{children:"stem_builder"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="lib/workflows/annotated.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/workflows.dart#workflows-annotated',children:"@WorkflowDefn(name: 'approvals.flow')\nclass ApprovalsAnnotatedWorkflow {\n  @workflow.step\n  Future<String> draft(FlowContext ctx) async {\n    final payload = ctx.params['draft'] as Map<String, Object?>;\n    return payload['documentId'] as String;\n  }\n\n  @WorkflowStep(name: 'manager-review')\n  Future<String?> managerReview(FlowContext ctx) async {\n    final resume = ctx.takeResumeData() as Map<String, Object?>?;\n    if (resume == null) {\n      ctx.awaitEvent('approvals.manager');\n      return null;\n    }\n    return resume['approvedBy'] as String?;\n  }\n\n  @workflow.step\n  Future<String> finalize(FlowContext ctx) async {\n    final approvedBy = ctx.previousResult as String?;\n    return 'approved-by:$approvedBy';\n  }\n}\n\n@WorkflowDefn(name: 'billing.retry-script', kind: WorkflowKind.script)\nclass BillingRetryAnnotatedWorkflow {\n  @workflow.run\n  Future<String> run(WorkflowScriptContext script) async {\n    final chargeId = await script.step<String>('charge', (ctx) async {\n      final resume = ctx.takeResumeData() as Map<String, Object?>?;\n      if (resume == null) {\n        await ctx.awaitEvent('billing.charge.prepared');\n        return 'pending';\n      }\n      return resume['chargeId'] as String;\n    });\n\n    return script.step<String>('confirm', (ctx) async {\n      ctx.idempotencyKey('confirm-$chargeId');\n      return 'receipt-$chargeId';\n    });\n  }\n}\n\n@TaskDefn(\n  name: 'send_email',\n  options: TaskOptions(maxRetries: 5),\n)\nFuture<void> sendEmail(\n  TaskInvocationContext ctx,\n  Map<String, Object?> args,\n) async {\n  // send email\n}\n\nFuture<void> registerAnnotatedDefinitions(StemWorkflowApp app) async {\n  // Generated by stem_builder.\n  registerStemDefinitions(\n    workflows: app.runtime.registry,\n    tasks: app.app.registry,\n  );\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Build the registry (example):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"dart pub add --dev build_runner stem_builder\ndart run build_runner build\n"})}),"\n",(0,t.jsx)(n.h2,{id:"starting--awaiting-workflows",children:"Starting & Awaiting Workflows"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="bin/run_workflow.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/workflows.dart#workflows-run',children:"Future<void> runWorkflow(StemWorkflowApp workflowApp) async {\n  final runId = await workflowApp.startWorkflow(\n    'approvals.flow',\n    params: {\n      'draft': {'documentId': 'doc-42'},\n    },\n    cancellationPolicy: const WorkflowCancellationPolicy(\n      maxRunDuration: Duration(hours: 2),\n      maxSuspendDuration: Duration(minutes: 30),\n    ),\n  );\n\n  final result = await workflowApp.waitForCompletion<String>(\n    runId,\n    timeout: const Duration(minutes: 5),\n  );\n\n  if (result?.isCompleted == true) {\n    print('Workflow finished with ${result!.value}');\n  } else {\n    print('Workflow state: ${result?.status}');\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"waitForCompletion<T>"})," returns a ",(0,t.jsx)(n.code,{children:"WorkflowResult<T>"})," that includes the decoded\nvalue, original ",(0,t.jsx)(n.code,{children:"RunState"}),", and a ",(0,t.jsx)(n.code,{children:"timedOut"})," flag so callers can decide whether\nto keep polling or surface status upstream."]}),"\n",(0,t.jsx)(n.h3,{id:"cancellation-policies",children:"Cancellation policies"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"WorkflowCancellationPolicy"})," guards long-running runs. Use it to auto-cancel\nworkflows that exceed a wall-clock budget or remain suspended longer than\nallowed."]}),"\n",(0,t.jsx)(n.h2,{id:"suspension-events-and-groups-of-runs",children:"Suspension, Events, and Groups of Runs"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"sleep(duration)"})," stores a wake-up timestamp; the runtime polls ",(0,t.jsx)(n.code,{children:"dueRuns"})," and\nresumes those runs by re-enqueuing the internal workflow task."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"awaitEvent(topic, deadline: ...)"})," registers durable watchers so external\nservices can ",(0,t.jsx)(n.code,{children:"emit(topic, payload)"}),". The payload becomes ",(0,t.jsx)(n.code,{children:"resumeData"})," for the\nawaiting step."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"runsWaitingOn(topic)"})," exposes all runs suspended on a channel\u2014useful for CLI\ntooling or dashboards. After a topic resumes the runtime calls\n",(0,t.jsx)(n.code,{children:"markResumed(runId, data: suspensionData)"})," so flows can inspect the payload."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Because watchers and due runs are persisted in the ",(0,t.jsx)(n.code,{children:"WorkflowStore"}),", you can\noperate on ",(0,t.jsx)(n.em,{children:"groups"})," of workflows (pause, resume, or inspect every run waiting on\na topic) even if no worker is currently online."]}),"\n",(0,t.jsx)(n.h2,{id:"run-leases--multi-worker-recovery",children:"Run Leases & Multi-Worker Recovery"}),"\n",(0,t.jsx)(n.p,{children:"Workflow runs are lease-based: a worker claims a run for a fixed duration,\nrenews the lease while executing, and releases it on completion. This prevents\ntwo workers from executing the same run concurrently while still allowing\ntakeover after crashes."}),"\n",(0,t.jsx)(n.p,{children:"Operational guidance:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Keep ",(0,t.jsx)(n.code,{children:"runLeaseDuration"})," ",(0,t.jsx)(n.strong,{children:">="})," the broker visibility timeout so redelivered\nworkflow tasks retry instead of being dropped before the lease expires."]}),"\n",(0,t.jsxs)(n.li,{children:["Ensure workers renew leases (",(0,t.jsx)(n.code,{children:"leaseExtension"}),") before either the workflow\nlease or broker visibility timeout expires."]}),"\n",(0,t.jsx)(n.li,{children:"Keep system clocks in sync (NTP) because lease expiry is time-based across\nworkers and the shared store."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"deterministic-tests-with-workflowclock",children:"Deterministic Tests with WorkflowClock"}),"\n",(0,t.jsxs)(n.p,{children:["Inject a ",(0,t.jsx)(n.code,{children:"WorkflowClock"})," when you need deterministic timestamps (e.g. for lease\nexpiry or due run scheduling). The ",(0,t.jsx)(n.code,{children:"FakeWorkflowClock"})," lets tests advance time\nwithout waiting on real timers."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final clock = FakeWorkflowClock(DateTime.utc(2024, 1, 1));\nfinal store = InMemoryWorkflowStore(clock: clock);\nfinal runtime = WorkflowRuntime(\n  stem: stem,\n  store: store,\n  eventBus: InMemoryEventBus(store: store),\n  clock: clock,\n);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"payload-encoders-in-workflow-apps",children:"Payload Encoders in Workflow Apps"}),"\n",(0,t.jsxs)(n.p,{children:["Workflows execute on top of a ",(0,t.jsx)(n.code,{children:"Stem"})," worker, so they inherit the same\n",(0,t.jsx)(n.code,{children:"TaskPayloadEncoder"})," facilities as regular tasks. ",(0,t.jsx)(n.code,{children:"StemWorkflowApp.create"}),"\naccepts either a shared ",(0,t.jsx)(n.code,{children:"TaskPayloadEncoderRegistry"})," or explicit defaults:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="lib/workflows/bootstrap.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/workflows.dart#workflows-encoders',children:"final encoders = TaskPayloadEncoderRegistry(\n  defaultArgsEncoder: const JsonTaskPayloadEncoder(),\n  defaultResultEncoder: const Base64PayloadEncoder(),\n);\n\nFuture<void> configureWorkflowEncoders() async {\n  final app = await StemWorkflowApp.create(\n    flows: [ApprovalsFlow.flow],\n    encoderRegistry: encoders,\n    additionalEncoders: const [GzipPayloadEncoder()],\n  );\n\n  await app.close();\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Every workflow run task stores the result encoder id in ",(0,t.jsx)(n.code,{children:"RunState.resultMeta"}),",\nand the internal tasks dispatched by workflows reuse the same registry\u2014so\ntyped steps can safely emit encrypted/binary payloads while workers decode them\nexactly once."]}),"\n",(0,t.jsxs)(n.p,{children:["Need per-workflow overrides? Register custom encoders on individual task\nhandlers (via ",(0,t.jsx)(n.code,{children:"TaskMetadata"}),") or attach a specialized encoder to a ",(0,t.jsx)(n.code,{children:"Flow"}),"/script\nstep that persists sensitive data in the workflow store."]}),"\n",(0,t.jsx)(n.h2,{id:"tooling-tips",children:"Tooling Tips"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"workflowApp.store.listRuns(...)"})," to filter by workflow/status when\nbuilding admin dashboards."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"workflowApp.runtime.emit(topic, payload)"})," is the canonical way to resume\nbatches of runs waiting on external events."]}),"\n",(0,t.jsxs)(n.li,{children:["CLI integrations (see ",(0,t.jsx)(n.code,{children:"stem workflow ..."}),") rely on the same store APIs, so\nkeeping the store tidy (expired runs, watchers) ensures responsive tooling."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var s=r(6540);const t={},o=s.createContext(t);function i(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);