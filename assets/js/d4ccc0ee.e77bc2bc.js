"use strict";(globalThis.webpackChunksite=globalThis.webpackChunksite||[]).push([[8218],{5541:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"workers/index","title":"Workers","description":"Workers pull tasks, manage concurrency, and publish lifecycle signals. Use these","source":"@site/docs/workers/index.md","sourceDirName":"workers","slug":"/workers","permalink":"/stem/workers","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/stem/tree/main/.site/docs/docs/workers/index.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"title":"Workers","slug":"/workers","sidebar_position":0},"sidebar":"docs","previous":{"title":"CLI & Control","permalink":"/stem/core-concepts/cli-control"},"next":{"title":"Programmatic Usage","permalink":"/stem/workers/programmatic"}}');var i=r(4848),t=r(8453);const o={title:"Workers",slug:"/workers",sidebar_position:0},a=void 0,l={},c=[{value:"Minimal entrypoints",id:"minimal-entrypoints",level:2},{value:"Redis-backed worker",id:"redis-backed-worker",level:2},{value:"Lifecycle overview",id:"lifecycle-overview",level:2},{value:"Queue subscriptions",id:"queue-subscriptions",level:2},{value:"Concurrency &amp; autoscaling",id:"concurrency--autoscaling",level:2},{value:"Key environment variables",id:"key-environment-variables",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Workers pull tasks, manage concurrency, and publish lifecycle signals. Use these\nguides to embed workers programmatically and operate them in production."}),"\n",(0,i.jsx)(n.h2,{id:"minimal-entrypoints",children:"Minimal entrypoints"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="workers_programmatic.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/workers_programmatic.dart#workers-worker-minimal',children:"class EmailTask extends TaskHandler<void> {\n  @override\n  String get name => 'email.send';\n\n  @override\n  TaskOptions get options => const TaskOptions(maxRetries: 2);\n\n  @override\n  Future<void> call(TaskContext context, Map<String, Object?> args) async {\n    final to = args['to'] as String;\n    print('Sending to $to (attempt ${context.attempt})');\n  }\n}\n\nFuture<void> minimalWorker() async {\n  final registry = SimpleTaskRegistry()..register(EmailTask());\n  final broker = InMemoryBroker();\n  final backend = InMemoryResultBackend();\n\n  final worker = Worker(\n    broker: broker,\n    registry: registry,\n    backend: backend,\n    queue: 'default',\n  );\n\n  await worker.start();\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="workers_programmatic.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/workers_programmatic.dart#workers-producer-minimal',children:"Future<void> minimalProducer() async {\n  final registry = SimpleTaskRegistry()\n    ..register(\n      FunctionTaskHandler<void>(\n        name: 'email.send',\n        entrypoint: (context, args) async {\n          final to = args['to'] as String? ?? 'friend';\n          print('Queued email to $to');\n          return null;\n        },\n      ),\n    );\n\n  final broker = InMemoryBroker();\n  final backend = InMemoryResultBackend();\n  final stem = Stem(\n    broker: broker,\n    registry: registry,\n    backend: backend,\n  );\n\n  final taskId = await stem.enqueue(\n    'email.send',\n    args: {'to': 'hello@example.com', 'subject': 'Welcome'},\n  );\n\n  print('Enqueued $taskId');\n  await backend.close();\n  await broker.close();\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"redis-backed-worker",children:"Redis-backed worker"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="workers_programmatic.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/workers_programmatic.dart#workers-worker-redis',children:"Future<void> redisWorker() async {\n  final brokerUrl =\n      Platform.environment['STEM_BROKER_URL'] ?? 'redis://localhost:6379';\n  final registry = SimpleTaskRegistry()..register(RedisEmailTask());\n\n  final worker = Worker(\n    broker: await RedisStreamsBroker.connect(brokerUrl),\n    registry: registry,\n    backend: await RedisResultBackend.connect('$brokerUrl/1'),\n    queue: 'default',\n    concurrency: Platform.numberOfProcessors,\n  );\n\n  await worker.start();\n}\n\nclass RedisEmailTask extends TaskHandler<void> {\n  @override\n  String get name => 'email.send';\n\n  @override\n  TaskOptions get options => const TaskOptions(\n    queue: 'default',\n    maxRetries: 3,\n    visibilityTimeout: Duration(seconds: 30),\n  );\n\n  @override\n  Future<void> call(TaskContext context, Map<String, Object?> args) async {}\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="workers_programmatic.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/workers_programmatic.dart#workers-producer-redis',children:"Future<void> redisProducer() async {\n  final brokerUrl =\n      Platform.environment['STEM_BROKER_URL'] ?? 'redis://localhost:6379';\n  final broker = await RedisStreamsBroker.connect(brokerUrl);\n  final backend = await RedisResultBackend.connect('$brokerUrl/1');\n  final registry = SimpleTaskRegistry()\n    ..register(\n      FunctionTaskHandler<void>(\n        name: 'report.generate',\n        entrypoint: (context, args) async {\n          final id = args['reportId'] as String? ?? 'unknown';\n          print('Queued report $id');\n          return null;\n        },\n      ),\n    );\n\n  final stem = Stem(\n    broker: broker,\n    registry: registry,\n    backend: backend,\n  );\n\n  await stem.enqueue(\n    'report.generate',\n    args: {'reportId': 'monthly-2025-10'},\n    options: const TaskOptions(queue: 'reports'),\n  );\n  await backend.close();\n  await broker.close();\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"lifecycle-overview",children:"Lifecycle overview"}),"\n",(0,i.jsxs)(n.p,{children:["Workers connect to the broker, claim deliveries, execute task handlers, and\nemit lifecycle signals as they progress (",(0,i.jsx)(n.code,{children:"taskReceived"}),", ",(0,i.jsx)(n.code,{children:"taskPrerun"}),",\n",(0,i.jsx)(n.code,{children:"taskPostrun"}),", ",(0,i.jsx)(n.code,{children:"taskSucceeded"}),", ",(0,i.jsx)(n.code,{children:"taskFailed"}),"). Worker-level signals announce\nstartup, readiness, heartbeat, and shutdown so dashboards and alerts can track\ncapacity in near real time."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="signals.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/signals.dart#signals-worker-listeners',children:"SignalSubscription registerWorkerSignals() {\n  return StemSignals.workerReady.connect((payload, _) {\n    print('Worker ready: ${payload.worker.id}');\n  });\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Shutdowns are cooperative: warm stops fetching new work, soft requests\ntermination checkpoints, and hard requeues active deliveries. The Worker\nControl CLI sends those commands through the same control queues the dashboard\nuses, so operational tooling stays consistent."}),"\n",(0,i.jsx)(n.h2,{id:"queue-subscriptions",children:"Queue subscriptions"}),"\n",(0,i.jsx)(n.p,{children:"Workers can subscribe to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"A single queue"})," (default: ",(0,i.jsx)(n.code,{children:"default"}),") for straightforward deployments."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multiple queues"})," by configuring a routing subscription (priority queues,\nfan-out, or dedicated lanes per workload)."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Queue subscriptions determine which stream shards the worker polls, so keep\nqueue names stable and document them alongside task registries."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="routing.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/routing.dart#routing-bootstrap',children:"Future<(Stem, Worker)> bootstrapStem() async {\n  final routing = await loadRouting();\n  final registry = SimpleTaskRegistry()..register(EmailTask());\n  final config = StemConfig.fromEnvironment();\n  final subscription = RoutingSubscription(\n    queues: config.workerQueues.isEmpty\n        ? [config.defaultQueue]\n        : config.workerQueues,\n    broadcastChannels: config.workerBroadcasts,\n  );\n\n  final stem = Stem(\n    broker: await RedisStreamsBroker.connect('redis://localhost:6379'),\n    registry: registry,\n    backend: InMemoryResultBackend(),\n    routing: routing,\n  );\n\n  final worker = Worker(\n    broker: await RedisStreamsBroker.connect('redis://localhost:6379'),\n    registry: registry,\n    backend: InMemoryResultBackend(),\n    subscription: subscription,\n  );\n\n  return (stem, worker);\n}\n\nclass EmailTask extends TaskHandler<void> {\n  @override\n  String get name => 'email.send';\n\n  @override\n  TaskOptions get options => const TaskOptions(queue: 'default');\n\n  @override\n  Future<void> call(TaskContext context, Map<String, Object?> args) async {}\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"concurrency--autoscaling",children:"Concurrency & autoscaling"}),"\n",(0,i.jsxs)(n.p,{children:["Workers run multiple tasks in parallel using isolate pools. Configure base\nconcurrency with ",(0,i.jsx)(n.code,{children:"concurrency"}),", then enable autoscaling to expand/contract\nwithin a min/max range based on backlog and inflight counts."]}),"\n",(0,i.jsx)(n.p,{children:"Prefetch controls how aggressively a worker claims work ahead of execution.\nUse smaller values for fairness and larger values for throughput. If you're\nusing autoscaling, align the prefetch multiplier with your maximum concurrency\nso scaling does not starve queues."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="worker_control.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/worker_control.dart#worker-control-autoscale',children:"final worker = Worker(\n  broker: _autoscaleBroker,\n  registry: SimpleTaskRegistry(),\n  backend: _autoscaleBackend,\n  queue: 'critical',\n  concurrency: 12,\n  autoscale: const WorkerAutoscaleConfig(\n    enabled: true,\n    minConcurrency: 2,\n    maxConcurrency: 12,\n    scaleUpStep: 2,\n    scaleDownStep: 1,\n    idlePeriod: Duration(seconds: 45),\n    tick: Duration(milliseconds: 250),\n  ),\n);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"key-environment-variables",children:"Key environment variables"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"STEM_BROKER_URL"})," \u2013 broker connection string (Redis/Postgres/memory)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"STEM_RESULT_BACKEND_URL"})," \u2013 durable result backend (optional but recommended)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"STEM_DEFAULT_QUEUE"})," \u2013 fallback queue when routing is unset."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"STEM_PREFETCH_MULTIPLIER"})," \u2013 prefetch multiplier applied to concurrency."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"STEM_WORKER_QUEUES"})," \u2013 explicit queue subscriptions (comma separated)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"STEM_WORKER_BROADCASTS"})," \u2013 broadcast channel subscriptions (comma separated)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"STEM_WORKER_NAMESPACE"})," \u2013 worker heartbeat/control namespace (observability)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"STEM_ROUTING_CONFIG"})," \u2013 path to routing config (YAML/JSON)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"STEM_SIGNING_*"})," \u2013 enable payload signing for tamper detection."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"STEM_TLS_*"})," \u2013 TLS settings for broker/backends."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/stem/workers/programmatic",children:"Programmatic Integration"})})," \u2013 Wire producers\nand workers inside your Dart services (includes in-memory and Redis examples)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/stem/workers/control",children:"Worker Control CLI"})})," \u2013 Inspect, revoke, scale, and\nshut down workers remotely."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/stem/workers/daemonization",children:"Daemonization Guide"})})," \u2013 Run workers under systemd,\nlaunchd, or custom supervisors."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Looking for retry tuning or task registries? See the\n",(0,i.jsx)(n.a,{href:"/stem/core-concepts",children:"Core Concepts"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var s=r(6540);const i={},t=s.createContext(i);function o(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);