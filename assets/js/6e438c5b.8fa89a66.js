"use strict";(globalThis.webpackChunksite=globalThis.webpackChunksite||[]).push([[4165],{8013:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"core-concepts/index","title":"Core Concepts","description":"Understand the building blocks that power Stem. These pages explain how tasks,","source":"@site/docs/core-concepts/index.md","sourceDirName":"core-concepts","slug":"/core-concepts","permalink":"/stem/core-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/stem/tree/main/.site/docs/docs/core-concepts/index.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"title":"Core Concepts","slug":"/core-concepts","sidebar_position":0},"sidebar":"docs","previous":{"title":"Retry & Backoff","permalink":"/stem/getting-started/retry-backoff"},"next":{"title":"Tasks","permalink":"/stem/core-concepts/tasks"}}');var r=s(4848),i=s(8453);const a={title:"Core Concepts",slug:"/core-concepts",sidebar_position:0},o=void 0,c={},l=[{value:"Feature Highlights",id:"feature-highlights",level:3},{value:"Core Concept Snippets",id:"core-concept-snippets",level:3}];function d(e){const n={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Understand the building blocks that power Stem. These pages explain how tasks,\nworkers, routing, signals, and canvases fit together so you can reason about\nbehavior before touching production."}),"\n",(0,r.jsx)(n.h3,{id:"feature-highlights",children:"Feature Highlights"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Queueing and retries with ",(0,r.jsx)(n.code,{children:"Stem.enqueue"}),", ",(0,r.jsx)(n.code,{children:"TaskOptions"}),", and retry\nstrategies."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"StemClient"})," entrypoint to share broker/backend configuration across workers\nand workflow apps."]}),"\n",(0,r.jsx)(n.li,{children:"Worker lifecycle management, concurrency controls, and graceful shutdown."}),"\n",(0,r.jsx)(n.li,{children:"Beat scheduler for interval/cron/solar/clocked jobs."}),"\n",(0,r.jsx)(n.li,{children:"Canvas primitives (chains, groups, chords) for task composition."}),"\n",(0,r.jsx)(n.li,{children:"Lifecycle signals for instrumentation and integrations."}),"\n",(0,r.jsx)(n.li,{children:"Declarative routing across queues and broadcast channels."}),"\n",(0,r.jsxs)(n.li,{children:["Result backends and progress reporting via ",(0,r.jsx)(n.code,{children:"TaskContext"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"core-concept-snippets",children:"Core Concept Snippets"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",metastring:'title="lib/tasks.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/tasks.dart#tasks-register-in-memory',children:"class EmailTask extends TaskHandler<void> {\n  @override\n  String get name => 'email.send';\n\n  @override\n  TaskOptions get options => const TaskOptions(maxRetries: 2);\n\n  @override\n  Future<void> call(TaskContext context, Map<String, Object?> args) async {\n    final to = args['to'] as String? ?? 'anonymous';\n    print('Emailing $to (attempt ${context.attempt})');\n  }\n}\n\nfinal registry = SimpleTaskRegistry()..register(EmailTask());\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",metastring:'title="lib/routing.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/routing.dart#routing-inline',children:"final inlineRegistry = RoutingRegistry(\n  RoutingConfig(\n    defaultQueue: const DefaultQueueConfig(alias: 'default', queue: 'primary'),\n    queues: {'primary': QueueDefinition(name: 'primary')},\n    routes: [\n      RouteDefinition(\n        match: RouteMatch.fromJson(const {'task': 'reports.*'}),\n        target: RouteTarget(type: 'queue', name: 'primary'),\n      ),\n    ],\n  ),\n);\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",metastring:'title="lib/signals.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/signals.dart#signals-configure',children:"void configureSignals() {\n  StemSignals.configure(\n    configuration: const StemSignalConfiguration(\n      enabled: true,\n      enabledSignals: {'worker-heartbeat': false},\n    ),\n  );\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",metastring:'title="lib/canvas_chain.dart" file=<rootDir>/../packages/stem/example/docs_snippets/lib/canvas_chain.dart#canvas-chain',children:"Future<void> main() async {\n  final app = await StemApp.inMemory(\n    tasks: [\n      FunctionTaskHandler<String>(\n        name: 'fetch.user',\n        entrypoint: (context, args) async => 'Ada',\n      ),\n      FunctionTaskHandler<String>(\n        name: 'enrich.user',\n        entrypoint: (context, args) async {\n          final prev = context.meta['chainPrevResult'] as String? ?? 'Friend';\n          return '$prev Lovelace';\n        },\n      ),\n      FunctionTaskHandler<Object?>(\n        name: 'send.email',\n        entrypoint: (context, args) async {\n          final fullName =\n              context.meta['chainPrevResult'] as String? ?? 'Friend';\n          print('Sending email to $fullName');\n          return null;\n        },\n      ),\n    ],\n    workerConfig: const StemWorkerConfig(\n      consumerName: 'chain-worker',\n      concurrency: 1,\n      prefetchMultiplier: 1,\n    ),\n  );\n  await app.start();\n\n  final canvas = app.canvas;\n  final chainResult = await canvas.chain([\n    task('fetch.user'),\n    task('enrich.user'),\n    task('send.email'),\n  ]);\n\n  print(\n    'Chain completed with state: ${chainResult.finalStatus?.state} '\n    'value=${chainResult.value}',\n  );\n\n  await app.close();\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/stem/core-concepts/tasks",children:"Tasks & Retries"})})," \u2013 Task handlers, options, retries, and idempotency guidelines."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/stem/core-concepts/producer",children:"Producer API"})})," \u2013 Enqueue tasks with args, metadata, signing, and delays."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/stem/core-concepts/signing",children:"Payload Signing"})})," \u2013 Sign envelopes, rotate keys, and verify signatures."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/stem/core-concepts/rate-limiting",children:"Rate Limiting"})})," \u2013 Throttle hot handlers with shared limits."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/stem/core-concepts/uniqueness",children:"Uniqueness"})})," \u2013 Deduplicate naturally unique tasks."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/stem/core-concepts/namespaces",children:"Namespaces"})})," \u2013 Isolate environments and tenants."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/stem/core-concepts/routing",children:"Routing"})})," \u2013 Queue aliases, priorities, and broadcast channels."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/stem/core-concepts/signals",children:"Signals"})})," \u2013 Lifecycle hooks for instrumentation and integrations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/stem/core-concepts/canvas",children:"Canvas Patterns"})})," \u2013 Chains, groups, and chords for composing work."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/stem/core-concepts/observability",children:"Observability"})})," \u2013 Metrics, traces, logging, and lifecycle signals."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/stem/core-concepts/persistence",children:"Persistence & Stores"})})," \u2013 Result backends, schedule/lock stores, and revocation storage."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/stem/core-concepts/workflows",children:"Workflows"})})," \u2013 Durable Flow/Script runtimes with typed results, suspensions, and event watchers."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/stem/core-concepts/cli-control",children:"CLI & Control"})})," \u2013 Quickly inspect queues, workers, and health from the command line."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Continue with the ",(0,r.jsx)(n.a,{href:"/stem/workers",children:"Workers guide"})," for operational details."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(6540);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);